#week5
#Task 1 Client for work with metrics

"""Реализация клиента.
# Необходимо реализовать класс Client, в котором будет инкапсулировано 
# соединение с сервером, 
# клиентский сокет и 
# методы для получения (get) и отправки (put) метрик на сервер. 

# Отправка и получение данных в методах get и put должна быть реализована
# в соответствии с протоколом, описанным выше. 
# В конструктор класса Client должна передаваться адресная пара хост 
# и порт, а также необязательный аргумент timeout (имеющий значение по 
#умолчанию - None). Соединение с сервером устанавливается при создании 
#экземпляра класса Client и не должно разрываться между запросами. 

Итак, в качестве решения вам необходимо предоставить модуль с реализованным 
в нем классом Client, пользовательским исключением ClientError. 

В классе Client должны быть доступны методы get и put с описанной выше сигнатурой. 
При вызове методов get и put клиент должен 
- посылать сообщения в TCP-соединение с сервером (в соответствии с описанным текстовым протоколом), 
- получать ответ от сервера и возвращать словарь с данными, в формате описанном выше.

Примечание.
Не смотря на то, что на этой неделе вы изучали асинхронность, клиент должен быть синхронным. 
Не расстраивайтесь, если вы хотели попробовать свои силы в написании асинхронного кода, 
на следующей неделе вам представится такая возможность.
"""


# реализация сервера для тестирования метода get по заданию - Клиент для отправки метрик
#!/usr/bin/env python
# -*- coding: utf-8 -*-

import socket

sock = socket.socket()
sock.bind(('127.0.0.1', 8888))
sock.listen(1)
conn, addr = sock.accept()

print('Соединение установлено:', addr)

# переменная response хранит строку возвращаемую сервером, если вам для
# тестирования клиента необходим другой ответ, измените ее
response = b'ok\npalm.cpu 10.5 1501864247\neardrum.cpu 15.3 1501864259\n\n'

while True:
    data = conn.recv(1024)
    if not data:
        break
    request = data.decode('utf-8')
    print(f'Получен запрос: {ascii(request)}')
    print(f'Отправлен ответ {ascii(response.decode("utf-8"))}')
    conn.send(response)

conn.close()


class Client():
    
    def __init__(self) -> None:
        pass
    
    def get(self):
        """Метод get принимает в качестве параметра имя метрики, значения 
        # которой мы хотим получить. В качестве имени метрики можно использовать 
        # символ «*», о котором мы упоминали в описании протокола.

        # Метод get возвращает словарь с метриками (смотрите пример ниже) 
        # в случае успешного получения ответа от сервера и выбрасывает исключение 
        # ClientError в случае не успешного.
        """
        pass
    
    def put(self):
        """
        Метод put принимает в качестве параметров: название метрики, 
        численное значение и необязательный именованный параметр timestamp. 
        Если пользователь вызвал метод put без аргумента timestamp, 
        то клиент автоматически должен подставить значение временной отметки, 
        полученное с помощью вызова int(time.time()).

        Метод put не возвращает ничего в случае успешной отправки и выбрасывает 
        пользовательское исключение ClientError в случае не успешной.
        Клиент получает данные от сервера в текстовом виде, метод get 
        должен обработать строку ответа и вернуть словарь с полученными ключами 
        с сервера. Значением ключей в словаре является список кортежей:
        [(timestamp1, metric_value1), (timestamp2, metric_value2), …]

        Значение timestamp и metric_value должны быть преобразованы соответственно к типам int и float. Список должен быть отсортирован по значению timestamp (по возрастанию).

        Пример возвращаемого значения при успешном вызове client.get("palm.cpu"):

        {
          'palm.cpu': [
            (1150864247, 0.5),
            (1150864248, 0.5)
          ]
        }

        """
        pass